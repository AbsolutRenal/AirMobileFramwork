/***  CLASS textDisplay*  Appliquer une feuille de style "étendue" à un textField 'dynamic' ou 'input'* */package fwk.text {	import fwk.utils.types.boolean.parseBoolean;	import flash.display.MovieClip;	import flash.filters.ColorMatrixFilter;	import flash.text.StyleSheet;	import flash.text.TextField;	import flash.text.TextFormat;				public class TextDisplay {				//propriétés du champ text		private var textProp:Object;		//feuille de style ratachée au champ text		private var myCss:StyleSheet;		//constructeur de la classe textDisplay				private var _currentScopeFunction:Object;		private var _tabTextObject: Array = new Array();						/**		 * Create an instance of TextDisplay		 * @param cssString A string represent the css		 */		public function TextDisplay(cssString:String):void{			//trace("new TextDisplay");								myCss = new StyleSheet();			myCss.parseCSS(cssString);		}				/**		 * Return the StyleSheet used		 * @return A StyleSheet		 */		public function get css():StyleSheet{			return myCss;		}		/**		 * Set a TextField from a node with the text and the style css info		 * @param mcT The clip contains the textField named (required) tTexte		 * @param node A xmlNode formatted with a attribute style (name style css with the prefix ".") to apply on the text and a text value		 * @param scopeFunction The scope will receive the event function in the text		 */		public function initTextFromNode(mcT:MovieClip, node:XML, scopeFunction:Object = null):void {						var t:TextObject = getTextObject(mcT);			if ( t == null) {				t = new TextObject();				if (scopeFunction != null) t.scopeFunction = scopeFunction;				//_tabTextObject.push(t);				mcT._textObject = t;								t.textField = mcT.getChildByName("tTexte") as TextField;				t.parentText = mcT;							}						//trace("test : " + node.toString());			//trace("style : " + node.attribute("style")[0]);			textProp = new Object();			textProp.style = node.attribute("style")[0];									setProp();						if (node.attribute("loc_x")[0] != undefined)textProp.xPos = node.attribute("loc_x")[0];			if (node.attribute("loc_y")[0] != undefined)textProp.yPos = node.attribute("loc_y")[0];						setText(node.toString(), t);			//setText(mcT.tTexte, node.toString());					}		/**		 * Set a TextField from a String and a style css		 * @param mcT The clip contains the textField named (required) tTexte		 * @param text A text string		 * @param className The style css name for the text (with the prefix ".")		 * @param scopeFunction The scope will receive the event function in the text		 */		public function initTextFromString(mcT:MovieClip, text:String, className:String, scopeFunction:Object = null):void {									//trace("initTextFromString " + text + " className " + className );						var t:TextObject = getTextObject(mcT);			if ( t == null) {				t = new TextObject();				if (scopeFunction != null) t.scopeFunction = scopeFunction;				//_tabTextObject.push(t);				mcT._textObject = t;								t.textField = mcT.getChildByName("tTexte") as TextField;				t.parentText = mcT;			}						textProp = new Object();			textProp.style = className;						setProp();						//trace("mcT.getChildByName(tTexte) " + mcT.getChildByName("tTexte"));									setText(text, t);		}				/**		 * Return the textFormat of the style css name		 * @param sStyle A style css name		 * @return A TextFormat		 */		public function styleToTextFormat(sStyle:String):TextFormat		{			textProp = new Object();			textProp.style = sStyle;			setProp();						var rTextFormat:TextFormat = new TextFormat();			rTextFormat.size = Number((textProp.fontSize).split("pt")[0]);			rTextFormat.font = textProp.fontFamily;			rTextFormat.color = Number("0x"+((textProp.color).split("#"))[1]);			rTextFormat.align = textProp.textAlign;						if (textProp.textDecoration == "underline") {				rTextFormat.underline = true;			}			if (textProp.fontWeight == "bold") {				rTextFormat.bold = true;			}			if (textProp.fontStyle == "italic") {				rTextFormat.italic = true;			}			if (textProp.letterSpacing != "null" && textProp.letterSpacing != undefined) {				rTextFormat.letterSpacing = textProp.letterSpacing;			}			if (textProp.mrm_leading != null && textProp.mrm_leading != "") {				rTextFormat.leading = textProp.mrm_leading;			}						return rTextFormat;		}		public function getTextObject(mc:MovieClip):TextObject		{						if( mc._textObject != null){				return mc._textObject;			}else{				return null;			}			/*for (var i:int = 0; i < _tabTextObject.length; i++) 			{				if ( _tabTextObject[i].parentText == mc) {					return _tabTextObject[i];				}			}*/					}				/**		* Fonction setProp		* Récupérer les propriétés classique et "étendue" (mrm_...) correspondant à la balise 'style'		*/		private function setProp():void {			//stringProp(textProp.style, "mrm_save", "");			stringProp(textProp.style, "mrm_restrict", "null");			stringProp(textProp.style, "mrm_thickness", "");			stringProp(textProp.style, "mrm_sharpness", "");			stringProp(textProp.style, "mrm_href", "");			stringProp(textProp.style, "mrm_asFunction", "");			stringProp(textProp.style, "width", "");			stringProp(textProp.style, "fontStyle", "normal");			stringProp(textProp.style, "fontWeight", "normal");			stringProp(textProp.style, "letterSpacing", "0");			stringProp(textProp.style, "mrm_leading", "");			stringProp(textProp.style, "textDecoration", "none");			stringProp(textProp.style, "fontFamily", "Arial");			stringProp(textProp.style, "fontSize", "12");			stringProp(textProp.style, "color", "0x000000");			stringProp(textProp.style, "mrm_backgroundColor", "0xFFFFFF");			stringProp(textProp.style, "mrm_maxChars", "");			stringProp(textProp.style, "mrm_borderColor", "0x000000");			stringProp(textProp.style, "mrm_antiAliasType", "advanced");			stringProp(textProp.style, "mrmalpha", "100");			stringProp(textProp.style, "textAlign", "left");			stringProp(textProp.style, "mrm_type", "dynamic");			stringProp(textProp.style, "mrm_posx", "");			stringProp(textProp.style, "mrm_posy", "");			stringProp(textProp.style, "mrm_selectionColor", "");						booleanProp(textProp.style, "mrm_bullet", "false");			booleanProp(textProp.style, "mrm_autoSize", "false");			booleanProp(textProp.style, "mrm_background", "false");			booleanProp(textProp.style, "mrm_mouseWheelEnabled", "false");			booleanProp(textProp.style, "mrm_border", "false");			booleanProp(textProp.style, "mrm_selectable", "false");			booleanProp(textProp.style, "mrm_multiline", "false");			booleanProp(textProp.style, "mrm_password", "false");			booleanProp(textProp.style, "mrm_embedFonts", "true");			booleanProp(textProp.style, "mrm_html", "true");			booleanProp(textProp.style, "mrm_wordWrap", "true");			booleanProp(textProp.style, "mrm_uppercase", "false");			booleanProp(textProp.style, "mrm_mouseEnabled", "false");			booleanProp(textProp.style, "mrm_bitmap", "false");			booleanProp(textProp.style, "mrm_gridFitType", "none");						booleanProp(textProp.style, "mrm_wmode", "true");						booleanProp(textProp.style, "verticalAlign", "false");			booleanProp(textProp.style, "horizontalAlign", "false");		}		/**		* Fonction stringProp		* Affecter a textProp une nouvelle propriété non Boolean (String, couleur)		* @param	style        : nom de la balise de formatage principale		* @param	prop         : nom de la propriété tel quel apparait dans la feuille de style		* @param	defaultValue : valeur que la propriété doit avoir si elle n'est pas référencée dans la feuille de style		*/		private function stringProp(style:String, prop:String, defaultValue:String):void {			(getProp(style, prop)) ? textProp[prop]=getProp(style, prop) : textProp[prop]=defaultValue;		}		/**		* Fonction booleanProp		* Affecter a textProp une nouvelle propriété Boolean, remplace false par "" pour pouvoir l'interpréter comme boolean		* @param	style        : nom de la balise de formatage principale		* @param	prop         : nom de la propriété tel quel apparait dans la feuille de style		* ( defaultValue : false , si la propriété n'es pas référencée)		*/		private function booleanProp(style:String, prop:String, defaultValue:String):void {			//////trace(Boolean("true")); ==> ////traces out "true"			//////trace(Boolean("")); ==> ////traces out "false" 			if (getProp(style, prop)) {				//si il est définie				if (getProp(style, prop) == "true") {					//si il vaut la chaine "true"					textProp[prop] = "true";				} else {					textProp[prop] = "";				}			} else {				(defaultValue == "true") ? textProp[prop]="true" : textProp[prop]="";			}		}		/**		* Fonction getProp		* Affecter a textProp une nouvelle propriété non Boolean (String, couleur)		* @param	style        : nom de la balise de formatage principale		* @param	prop         : nom de la propriété tel quel apparait dans la feuille de style		* @return	             : valeur correspondant à la propriété 'prop' de la feuille de style		*/		private function getProp(style:String, prop:String):String {			return myCss.getStyle(style)[prop];		}		private function addHidedProperty(style:String, asProp:String, value:Object):void {			myCss["_styles"][style][asProp] = value;		}		/**		* Fonction getProp		* Appliquer au champ texte sont contenut et son formatage		* @param	tf   : textField a formater		* @param	str  : contenut html à appliquer		*/		private function setText(str:String, currentTextObject:TextObject):void {			/*trace(" >> from textDisplay.setText :");			trace("       + style :          " + textProp.style);			trace("       + font :           " + textProp.fontFamily);			trace("       + data :           " + str);*/						//si c'est un champ en input, la feuille de style ne peut pas etre appilquée,			//le textFormat redéfinie nom ,couleur , et taille de la police												var textNew:TextField;						if (textProp.mrm_type == "input") {				currentTextObject.isInput = true;			}						currentTextObject.init();						textNew = currentTextObject;			textNew.styleSheet = null;			var my_fmt:TextFormat = new TextFormat();			my_fmt.size = Number((textProp.fontSize).split("pt")[0]);			my_fmt.font = textProp.fontFamily;			my_fmt.color = Number("0x"+((textProp.color).split("#"))[1]);			my_fmt.align = textProp.textAlign;									if (textProp.textDecoration == "underline") {				my_fmt.underline = true;			}			if (textProp.fontWeight == "bold") {				my_fmt.bold = true;			}			if (textProp.fontStyle == "italic") {				my_fmt.italic = true;			}			if (textProp.letterSpacing != "null" && textProp.letterSpacing != undefined) {				my_fmt.letterSpacing = textProp.letterSpacing;			}			if (textProp.mrm_leading != null && textProp.mrm_leading != "") {				my_fmt.leading = textProp.mrm_leading;			}						if (textProp.mrm_type == "input") {				//trace("       + type :       input");				//textNew.Pour input vide				currentTextObject.textItitial = str;				textProp.mrm_selectable = "true";							}else{				textNew.mouseEnabled = false;			}						if (Boolean(textProp.mrm_mouseEnabled)) {				textNew.mouseEnabled = true;			}						if (Boolean(textProp.mrm_autoSize)) {				textNew.wordWrap = Boolean(textProp.mrm_wordWrap);				textNew.autoSize = textProp.textAlign;				if(textProp.textAlign == "justify"){					textNew.autoSize = "center";				}			}else{				if (textProp.mrm_type == "input")				{					if(Boolean(textProp.mrm_wmode))					{					 	FirefoxWmodeFix.firefoxWmodeFix(textNew);					}else { }										if (textProp.mrm_multiline == "true")					{						textNew.wordWrap 	= true;					} else {						textNew.wordWrap 	= false;					}				} else {					textNew.wordWrap 	= Boolean(textProp.mrm_wordWrap);				}			}						if(textProp.mrm_restrict != "null" && textProp.mrm_restrict != undefined) {				textNew.restrict			= textProp.mrm_restrict;				}						textNew.embedFonts = Boolean(textProp.mrm_embedFonts);						// set TextFormat			textNew.defaultTextFormat = my_fmt;						if(textProp.width != "")				textNew.width = textProp.width;						textNew.multiline = Boolean(textProp.mrm_multiline);			textNew.type = textProp.mrm_type;			textNew.selectable = Boolean(textProp.mrm_selectable);			textNew.mouseWheelEnabled = Boolean(textProp.mrm_mouseWheelEnabled);			currentTextObject.isPassword = Boolean(textProp.mrm_password);			textNew.background = Boolean(textProp.mrm_background);			textNew.backgroundColor = Number(textProp.mrm_backgroundColor);			textNew.border = Boolean(textProp.mrm_border);			textNew.borderColor = Number(textProp.mrm_borderColor);			textNew.maxChars = Number(textProp.mrm_maxChars);						if(textProp.mrm_gridFitType != "none"){				textNew.antiAliasType = "advanced";				textNew.gridFitType = textProp.mrm_gridFitType;			} else {				textNew.antiAliasType = textProp.mrm_antiAliasType;			}						//textNew.alpha = Number(textProp.mrmalpha);			//textNew.mrm_save = String(textProp.mrm_save);			/*if (Number(textProp.mrm_leading)) {				addHidedProperty(textProp.style, "leading", Number(textProp.mrm_leading));			}*/						if (textProp.mrm_thickness != "") {				textNew.antiAliasType = "advanced";				textNew.thickness = Number(textProp.mrm_thickness);			}			if (textProp.mrm_sharpness != "")			{				textNew.antiAliasType = "advanced";				textNew.gridFitType = "none";				textNew.sharpness = Number(textProp.mrm_sharpness);			}						if (textProp.xPos) {				textNew.x = textProp.xPos;			}			if (textProp.yPos) {				textNew.y = textProp.yPos;			}			if (textProp.tabIndex) {				textNew.tabIndex = textProp.tabIndex;			}						if (textProp.mrm_posx != "") {				//trace("textProp.mrm_posx " + textProp.mrm_posx);				textNew.x = parseInt(textProp.mrm_posx);			}			if (textProp.mrm_posy != "") {				textNew.y = parseInt(textProp.mrm_posy);			}									// set styleSheet			if (textProp.mrm_type != "input") textNew.styleSheet = myCss;						if (Boolean(textProp.mrm_html)) {				//trace("       + html :         true");				//trace(str);				if (Boolean(textProp.mrm_uppercase)) {					textNew.htmlText = str.toUpperCase();				}else{					textNew.htmlText = str;				}			} else {				//trace("       + html :         false");				if (Boolean(textProp.mrm_uppercase)) {					textNew.text = str.toUpperCase();				}else{					textNew.text = str;				}			}						//											// si polices de periphériques, pour pouvoir appliquer un alpha			if (textProp.mrm_embedFonts == "") {								if (  !Boolean(textProp.mrm_autoSize) && !Boolean(textProp.mrm_multiline) )				{					currentTextObject.height = Number((textProp.fontSize).split("pt")[0]) + 10;				}							 				var filtre:ColorMatrixFilter = new ColorMatrixFilter();				currentTextObject.filters = [filtre];							}						// selction color			if ( textProp.mrm_type == "input" && textProp.mrm_selectionColor != "" )			{				SelectionColor.setFieldSelectionColor(currentTextObject, parseInt(textProp.mrm_selectionColor));			}									// trace le BitMap d'un champs texte			if (textProp.mrm_bitmap == "true")			{				currentTextObject.isBitmap = true;				currentTextObject.displayAsBitmap(true);			}else {				currentTextObject.isBitmap = false;				currentTextObject.displayAsBitmap(false);			}						if(parseBoolean(textProp.horizontalAlign)){				if(textProp.textAlign == "center")					textNew.x = - textNew.width / 2;				if(textProp.textAlign == "right")					textNew.x = - textNew.width;			}					if(parseBoolean(textProp.verticalAlign))				textNew.y = - textNew.height / 2;				}					}}import flash.display.Bitmap;import flash.display.BitmapData;import flash.display.DisplayObjectContainer;import flash.events.Event;import flash.events.FocusEvent;import flash.events.MouseEvent;import flash.events.TextEvent;import flash.text.TextField;	internal class TextObject extends TextField{	public var textField:TextField;	public var textItitial:String;		public var isPassword:Boolean = false;	public var isInput:Boolean = false;	private var _isBitmap:Boolean = false;		public var parentText:DisplayObjectContainer;	public var scopeFunction:Object;	public var bitmap:Bitmap;				public function TextObject():void	{	}		override public function set text(value:String):void 	{		super.text = value;				dispatchEvent(new Event("TextObjectChange"));	}		public function set isBitmap(value:Boolean):void 	{		_isBitmap = value;						if (_isBitmap)		{			drawBitmap();		}else {			displayAsBitmap(false);		}			}	public function init():void	{						if (bitmap != null && bitmap.parent != null) {			parentText.removeChild(bitmap);			bitmap = null;		}							//trace("textField.width " + textField.width);		//trace("parentText " + parentText);		this.width = textField.width;		this.height = textField.height;		this.x = textField.x;		this.y = textField.y;		parentText[textField.name] = this;				if ( this.parent == null)		{			this.name = textField.name;			parentText.addChild(this);		}				if (textField.parent != null) {			parentText.removeChild(textField);		}				// gestion link texte		this.addEventListener(TextEvent.LINK, linkHandler);								// listener text change		this.addEventListener("TextObjectChange", onTextChange);							if ( isInput)		{			//trace("text isInput");						parentText.addEventListener(MouseEvent.MOUSE_DOWN, onClickTexte);						// focus			parentText.addEventListener(FocusEvent.FOCUS_IN, onFocus);			parentText.addEventListener(FocusEvent.FOCUS_OUT, onFocusOut);		}			}		private function onTextChange(e:Event):void 	{		//trace("onTextChange");		if( _isBitmap) drawBitmap();	}	public function drawBitmap():void	{		var bmd:BitmapData = new BitmapData(parentText.width, parentText.height, true, 0);				if (bitmap == null)		{			// instance bitmap			bitmap = new Bitmap(bmd, "auto", true);			bitmap.visible = _isBitmap;			parentText.addChild(bitmap);		}						//trace("drawBitmap");		var flag:Boolean = bitmap.visible;		this.visible = true;		bitmap.visible = false;		bmd.draw(parentText);				if (flag) {			bitmap.visible = true;			this.visible = false;		}		//bitmap.x = this.x;		//bitmap.y = this.y;		bitmap.bitmapData = bmd;			}	public function displayAsBitmap(flag:Boolean):void	{				if (flag)		{			//trace("displayAsBitmap");						drawBitmap();			bitmap.visible = true;			this.visible = false;					}else {			this.visible = true;			if (bitmap != null) bitmap.visible = false;		}					}		private function linkHandler(evt:TextEvent):void{		try {			//trace("linkHandler " + evt.text);			//trace("scopeFunction " + scopeFunction);			if (scopeFunction != null) scopeFunction[evt.text]();		}		catch (error:ReferenceError) {			//trace("echec textEvent sur la fonction : " + evt.text);		}	}	private function onClickTexte(e:MouseEvent):void 	{		//trace("TextDisplay onClickTexte");		if(bitmap != null && bitmap.visible) parentText.stage.focus = this;					}	private function onFocus(evt:FocusEvent):void	{				//trace("text onFocus");		if (_isBitmap) displayAsBitmap(false);				if (this.text == " " || this.text == "" || this.text == textItitial) {			this.text = "";			if (isPassword) this.displayAsPassword = true;		}			}	private function onFocusOut(evt:FocusEvent):void {				//trace("text onFocusOut");				if (this.text == "") {			if (isPassword) this.displayAsPassword = false; 			this.text = textItitial;		} 		if(_isBitmap) displayAsBitmap(true);			}}